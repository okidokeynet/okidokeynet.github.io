<html>

<head>
    <meta charset="UTF-8">
    <title>OK: Search</title>

    <meta name="description"
        content="I don't want to sell anything, buy anything, or process anything as a career. I don't want to sell anything bought or processed, or buy anything sold or processed, or process anything sold, bought, or processed, or repair anything sold, bought, or processed. You know, as a career, I don't want to do that." />

    <style>
        body {
            /* filter: hue-rotate(310deg); */
            max-width: 100%;
            /* overflow-x: hidden; */
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 0;
        }

        /* body {
            background-color: lightpink;
         }
         @media screen and (max-width: 420px) {
            body {
               background-color: lightblue;
            }
         } */

        div.pagelink {
            /* width: 33vw; */
            white-space: normal;
            overflow-wrap: break-word;
            word-wrap: break-word;
            white-space: pre-line;
            word-wrap: break-word;
        }


        @media screen and (prefers-color-scheme: dark) {
            /* body {
                background: #2d3239;
                color: #75715e;
            }

            h1 {
                color: #e9d970;
            } */
        }

        .searchMeta { }

        div.message {
            text-align: center;
        }

        div.continuationSection {
            text-align: center;
            margin-left: auto;
            margin-right: auto;
            padding: 2em;
                        
        }

        #continuationButton {
            width: 80%;
            -webkit-appearance: button;
            appearance: button;
            cursor: pointer;
            /* background:transparent; */
            font-size: 1.5em;
            /* font-weight: bold; */
            /* font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; */
        }

        .halfWidth {
            width: 48vw;
            margin-left: 1vw;
            margin-right: 1vw;
        }

        .fullWidth {
            width: 98vw;
            margin-left: 1vw;
            margin-right: 1vw;
        }

        table.searchResult {
            table-layout: fixed;
            display: block;
            /* width: 200px; */
            background-color: lightsalmon;
            border-spacing: 0.5px;
            overflow-x: hidden;
            text-overflow: ellipsis;
        }

        td.recordKey  {
            width: 10vw;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            font-variant-caps: small-caps;
            text-align: right;
            font-size: 1em;
            vertical-align: text-top;
        }

        td.recordValue  {
            background-color: lightyellow;
            font-size: 1em;

            text-overflow: ellipsis;
            overflow: hidden;
            white-space: normal;
            word-wrap: break-word; 
            overflow-wrap: break-word;
        }

        .previewArea {
            height: 18em;
            font-size: 1em;
            scroll-behavior: smooth;
            overflow: scroll;
            overflow-x: hidden;
        }

        iframe.previewArea {
            /* visibility: hidden; */
            background-color: lemonchiffon;
            resize: vertical;
            padding: 0;
            border: 0;
            /* otherwise the border is different from the textarea */
            box-shadow: inset 0 0 1px;
            /* border: 0; */
            /* inset: 0; */
        }

        textarea.previewArea {
            resize: vertical;
            padding: 0.5em;
            border-radius: 5px;
            border: 2px rgba(#000000, 0.5);
            scrollbar-width: thin;
            background-color: aliceblue;
            text-align: justify;
            hyphens: auto;
            overflow-wrap: break-word;
            white-space: normal;
            text-align: justify;
            white-space: pre-line;
            -moz-text-align-last: left;
            text-align-last: left;
            font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        .previewArea::-webkit-scrollbar {
            width: 12px;
        }

        .previewArea::-webkit-scrollbar-button {}

        .previewArea::-webkit-scrollbar-track {
            -webkit-box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.5);
            box-shadow: inset 0 0 3px rgba(0, 0, 0, 0.5);
            border-radius: 5px;
        }

        .previewArea::-webkit-scrollbar-track-piece {}

        .previewArea::-webkit-scrollbar-thumb {
            border-radius: 5px;
            background: rgba(#000000, 0.8);
            -webkit-box-shadow: inset 0 0 6px rgba(0, 0, 0, 0.5);
        }

        .previewArea::-webkit-scrollbar-corner {}

        .previewArea::-webkit-resizer {}

        .previewArea::-webkit-scrollbar-thumb:window-inactive {
            background: rgba(#e89b4d, 0.4);
        }
    </style>
</head>

<body>
    <div style="margin-left: 1vw; margin-right: 1vw; margin-top: 1em; margin-bottom: 1em;">

        <form onsubmit="document.getElementById('summary').placeholder = 'OK: Searching…';">
            <input id="searchField" style="width: 37vw;" placeholder="Search terms" name="q" autofocus type="text"
                aria-autocomplete="both" aria-haspopup="false" autocapitalize="off" autocomplete="off" autocorrect="off"
                role="combobox" spellcheck="false" aria-label="Search" title="Individual search terms separated by spaces" />
            <input id="searchSubmit" type="submit" name="ok" value="Search" style="width: 10vw; padding-right: 1wv;" title="Search" />
            <input id="snippetLengthField" style="width: 4em" name="s" placeholder="sniplength" title="The length of the accessible text snippet in characters" />
            <input id="resultsLimitField" style="width: 4em" name="l" placeholder="limit" title="The number of results per batch" />
            <input id="mimeTypeField" style="width: 6em" name="m" placeholder="type" title="The MIME type of file to search for, such as text/html or application/pdf" />
            <input id="resultsDomainField" style="width: 10em" name="d" placeholder="host" title="The domain name constraint" />

            <!-- Orientation of interface  -->
            <input id='orient-t' type='radio' name='o' value='t' title="metadata above"><label>↑</label></input>
            <input id='orient-l' type='radio' name='o' value='l' title="metadata left"><label>←</label></input>
            <input id='orient-r' type='radio' name='o' value='r' title="metadata right"><label>→</label></input>
            <input id='orient-b' type='radio' name='o' value='b' title="metadata below"><label>↓</label></input>
            <input id='orient-h' type='radio' name='o' value='h' title="metadata hidden"><label>x</label></input>

            <input id="summary" placeholder="OK: Ready" disabled />
            <input id="token" type="hidden" name="t" />
            <input id="countOnly" type="checkbox" name="c" value="1" style="display: none;" />
            <input id="unindexed" type="checkbox" name="x" value="1" style="display: none;" />
        </form>
    </div>
    <hr />

    <div id="message">
    </div>

    <div id="results">
    </div>

    <div class="continuationSection">
        <input id="continuationButton" type="button" value="Load More" hidden onclick="performSearch(window.continuationResponse)" />
    </div>

    <!-- <div id="auth">
        <h5 data-bind="text: displayUserName"></h5>
        <div id="apple-sign-in-button"></div>
        <div id="apple-sign-out-button"></div>
    </div> -->


    <script>
        "use strict";

        const params = new URLSearchParams(window.location.search);
        const ok = typeof params.get('ok') === 'string';
        document.getElementById('token').value = params.get('t');

        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function reverseString(str) {
            return str.split("").reverse().join("");
        }

        function changeMode(type, recordName, rlink) {
            console.log("changeMode", type, recordName);
            let textarea = document.getElementById('textarea-' + recordName);
            let iframe = document.getElementById('iframe-' + recordName);

            if (type === 'text') {
                iframe.hidden = true;
                iframe.innerHTML = null;
                textarea.hidden = false;
                //iframe.src = 'about:blank'; // clear the iframe's source
            } else if (type === 'preview') {
                textarea.hidden = true;
                iframe.innerHTML = "<iframe class='previewArea halfWidth' referrerpolicy='no-referrer' sandbox='allow-forms allow-same-origin' src='about:blank src='" + rlink + "'></iframe>";
                iframe.hidden = false;
            }
        }

        const recordElement = function (record, snippetRenderTime, snipLength, orient) {
            let deleted = record['deleted'];
            if (deleted !== false) { return; }

            let fields = record.fields;
            if (typeof fields !== 'object') {
                console.warn("record.fields was not an object!");
                return;
            }

            // the record's URL, which is either the 'responseURL', or the 'recordName' if it isn't set
            let rname = record['recordName'] || '';
            let rlink = (fields['responseURL'] || {}).value || ("https://" + rname);

            let html = "<div style='display: flex;'>";

            function addSnippetSection(widthClass) {
                html += "<div class='searchMeta'>";

                html += "<textarea id='textarea-" + rname + "' class='previewArea " + widthClass + "' placeholder='Loading accessible snippet…' readonly>"
                html += "";
                let textObject = fields['text'];
                let snippet = (textObject || {}).value;
                snippet = escapeHtml(snippet.substring(0, snipLength));

                if (snippetRenderTime <= 0) {
                    if (typeof textObject === 'object') {
                        html += snippet;
                    }
                } else { // fill in snippets after a delay
                    let updateSnippet = function () {
                        (document.getElementById('textarea-' + rname) || {}).innerHTML = snippet;
                    };
                    setTimeout(updateSnippet, snippetRenderTime);
                }

                html += "</textarea>";

                html += "<div id='iframe-" + rname + "'></div>";

                html += "</div>";
            }

            function addMetadataSection(widthClass) {
                let keys = Object.keys(fields);
                keys = keys.sort();

                keys = [
                    "title",
                    "lastModified",
                    "indexDate",
                    "et", // "etag" was a reserved name
                    "contentType",
                    "statusCode",
                    "weight",
                    "height",
                    "text",
                    "langs",
                ];
                // console.log("loaded keys", keys);

                html += "<div>";

                html += "<table class='searchResult " + widthClass + "'>";

                keys.forEach(key => {
                    html += "<tr>";

                    html += "<td class='recordKey'>";
                    html += key;
                    html += "</td>";

                    html += "<td class='recordValue'>";

                    if (typeof fields[key] === 'undefined') {
                        // check the record along with the fields, so we can handle "recordName", "modifiedDate", etc.
                        if (typeof record[key] === 'string') {
                            html += record[key];
                        } else {
                            html += "<span style='font-variant-caps: small-caps;'>null</span>";
                        }
                    } else if (key == 'title') {
                        html += "<strong>";
                        html += escapeHtml(fields[key].value);
                        html += "</strong>";
                    } else if (key == 'indexDate' || key == 'lastModified') {
                        html += new Date(fields[key].value);
                    } else if (key == 'text') {
                        let textlen = fields[key].value.length;
                        html += textlen + " bytes";
                        let weight = (fields['weight'] || {}).value;
                        if (typeof weight === 'number') {
                            html += " (" + (textlen / weight) + "%)";
                        }
                    } else if (typeof fields[key] === 'object') {
                        html += fields[key].value;
                    } else {
                        html += "" // nothing
                    }
                    html += "</td>";

                    html += "</tr>";
                });

                let previewButtonStyle = "title='Preview URL in private script-less sandbox'";
                let fopts = (((fields['frameOptions'] || {}).value) + '').toUpperCase();
                if (fopts === 'SAMEORIGIN' || fopts === 'DENY') {
                    // when X-Frame-Options is SAMEORIGIN or DENY, iframe loading is prohibited
                    //console.log("FRAME", fopts, previewButtonStyle);
                    previewButtonStyle = "style='text-decoration: line-through;' title='Sandbox preview forbidden by server policy: " + fopts + "' disabled";
                }

                html += "<tr>";

                html += "<td class='recordKey'>";
                html += "Preview";
                html += "</td>";

                html += "<td class='recordValue'>";

                html += "<form>";
                html += "<input type='radio' name='mode' value='text' onclick='changeMode(\"text\", \"" + rname + "\", \"" + rlink + "\")' checked ><label for='text'>Snippet</label></input>"

                html += "&nbsp;";

                html += "<input type='radio' name='mode' value='preview' title='Preview accessible text snippet' onclick='changeMode(\"preview\", \"" + rname + "\", \"" + rlink + "\")' " + previewButtonStyle + ">";
                html += "<label for='preview' " + previewButtonStyle + ">Sandbox</label>";
                html += "</input>"
                html += "<br/>";

                html += "<div class='pagelink'><a class='pagelink' href='" + rlink + "'>" + rlink + "</a></div>";
                html += "</form>";

                html += "</td>";
                html += "</tr>";
                html += "</table>";

                html += "</div>"; // recordURL
            }
            
            (document.getElementById('orient-' + orient) || {}).checked = true;
            if (orient == "l") {
                addMetadataSection('halfWidth');
                addSnippetSection('halfWidth');
            } else if (orient == "r") {
                addSnippetSection('halfWidth');
                addMetadataSection('halfWidth');
            } else if (orient == "t") {
                addSnippetSection('fullWidth');
                html += "</div><div style='display: flex; margin-top: 1em;'>";
                addMetadataSection('fullWidth');
            } else if (orient == "b") {
                addSnippetSection('fullWidth');
                html += "</div><div style='display: flex; margin-top: 1em;'>";
                addMetadataSection('fullWidth');
            } else if (orient == "x") {
                addSnippetSection('fullWidth');                
            } else {
                // html += "bad orient: " + orient;
                addSnippetSection();
                addMetadataSection();
            }

            
            html += "</div>"; // searchResult
            return html;
        }

        const performSearch = function (continuationResponse) {
            document.getElementById('continuationButton').hidden = true;
            const isContinuation = typeof continuationResponse === 'object';

            let startTime = new Date();
            let container = CloudKit.getDefaultContainer();
            let database = container.publicCloudDatabase;

            let filters = [];

            let desiredKeys = undefined;
            let defaultResultsLimit = '10';

            const countOnly = params.get('c') === '1';
            document.getElementById('countOnly').checked = countOnly;
            if (countOnly === true) {
                console.log("countOnly");
                defaultResultsLimit = '999';
                desiredKeys = ["indexDate"]; 
            }

            const unindexed = params.get('x') === '1';
            document.getElementById('unindexed').checked = unindexed;

            if (unindexed === true) {
                console.log("unindexed");
                filters.push({
                    fieldName: 'indexDate',
                    comparator: 'EQUALS',
                    fieldValue: { value: 0 }
                });
            } else {
                filters.push({
                    fieldName: 'indexDate',
                    comparator: 'NOT_EQUALS',
                    fieldValue: { value: 0 }
                });
                filters.push({
                    fieldName: 'weight',
                    comparator: 'GREATER_THAN',
                    fieldValue: { value: 0 }
                });
            }

            let orient = params.get('o') || 'l'; // the orientation of the interface

            let lim = params.get('l');
            document.getElementById('resultsLimitField').value = lim;
            let resultsLimit = 10;
            if (typeof lim === 'string' && parseInt(lim) > 0) {
                resultsLimit = Math.max(1, parseInt(lim));
            }

            let snip = params.get('s');
            document.getElementById('snippetLengthField').value = snip;
            let snipLength = Number.max; // 1024 * 10; // Number.max;
            if (typeof slen === 'string' && parseInt(slen) > 0) {
                snipLength = Math.max(1, parseInt(slen));
                console.log("snipLength", snipLength);
            }

            const resultsDomain = params.get('d') || '';
            if (resultsDomain.length > 0) {
                document.getElementById('resultsDomainField').value = resultsDomain;
                filters.push({
                    fieldName: 'rhost',
                    comparator: 'BEGINS_WITH',
                    fieldValue: { value: reverseString(resultsDomain) }
                });
            }

            const resultsMIME = params.get('m') || '';
            if (resultsMIME.length > 0) {
                document.getElementById('mimeTypeField').value = resultsMIME;
                filters.push({
                    fieldName: 'rmime',
                    comparator: 'BEGINS_WITH',
                    fieldValue: { value: reverseString(resultsMIME) }
                });
            }

            // issue the query
            const queryString = params.get('q') || '';
            if (queryString.length > 0) {
                // pre-fill the search field
                document.getElementById('searchField').value = queryString;

                filters.push({
                    fieldName: 'text',
                    comparator: 'CONTAINS_ALL_TOKENS',
                    fieldValue: { value: queryString }
                });
            }

            let sortDescriptors = [];
            sortDescriptors.push({ // most recent first
                //"systemFieldName": "createdTimestamp",
                "systemFieldName": "modifiedTimestamp",
                "ascending": false
            });

            //document.getElementById('results').innerHTML = "OK: Searching…"

            // console.log("resultsLimit", resultsLimit);

            let query = {
                recordType: 'Page',
                sortBy: sortDescriptors,
                filterBy: filters,
            };

            let options = {
                desiredKeys: desiredKeys,
                resultsLimit: resultsLimit,
                numbersAsStrings: false
            };

            let div = document.getElementById('results');
            if (isContinuation !== true) {
                div.innerHTML = ""; // clear the current results unless this is a continuation
            } 
            
            let recordResults = [];
            let deferElementRender = 0; // 300; // the number of ms before we show the elements
            let snippetRenderTime = 0; // 200; // the initial snippet delay; incremented by deferSnippetRender
            let deferSnippetRender = 0; // 800; // the number of ms before we fill in the snippets textarea

            const handleResponse = function(response) {
                //console.log("record count", response.records.length);
                //console.log("receive response", response, response.records);

                let resultHTML = "";
                response.records.forEach(element => {
                    recordResults.push(element);
                    if (countOnly === false) {
                        // setTimeout(function() {
                        // }, recordResults.length * 10);
                        resultHTML += recordElement(element, snippetRenderTime, snipLength, orient) + "<hr />";

                        if (deferSnippetRender > 0 && snippetRenderTime > 0) {
                            snippetRenderTime += deferSnippetRender;
                        }
                    }
                });
                document.getElementById('results').innerHTML += resultHTML;

                let sum = document.getElementById('summary');
                let plus = response.moreComing == true ? "+" : "";
                let summaryText = recordResults.length + plus + " results in " + ((new Date().getTime() - startTime.getTime()) / 1000.0) + " seconds";
                sum.placeholder = summaryText;
                console.log(summaryText, "continuation", response.moreComing, response.continuationMarker);

                if (response.moreComing) {
                    window.continuationResponse = response;
                    document.getElementById('continuationButton').hidden = false;
                } else {
                    delete window.continuationResponse;
                    document.getElementById('continuationButton').hidden = true;
                }
            };

            database.performQuery(continuationResponse || query, options)
                .then(function (response) { handleResponse(response); })
                .catch(function (error) { console.warn(error); });
        };

        /**
         * This function is run immediately after CloudKit has loaded.
         * 
         * Data Size Limits: These are the limits on the size of data sent to and from the CloudKit server.
         *
         *  Maximum number of operations in a request: 200
         *  Maximum number of records in a response: 200
         *  Maximum number of tokens in a request: 200
         *  Maximum record size (not including Asset fields): 1 MB
         *  Maximum file size of an Asset field: 50 MB
         *  Maximum number of source references to a single target where the action is delete self: 750
         */
        const initCloudKit = function () {
            try {
                CloudKit.configure({
                    logger: window.console,
                    containers: [{
                        // auth window will say: "Sign in to iCloud.net.tiqtiq.TiqTiq"
                        containerIdentifier: 'iCloud.net.tiqtiq.TiqTiq',
                        environment: 'development',
                        apiTokenAuth: {
                            // note this only works with our origin host; use a local dev key in `t` for testing
                            apiToken: params.get('t') || 'a56fb0334eb8f142d81f36b4e59dd579d1407958f7084e2af48276a1514a9dcf',
                            persist: true, // Sets a cookie.
                            signInButton: {
                                id: 'apple-sign-in-button',
                                theme: 'white-with-outline' // options: 'black', 'white', 'white-with-outline'.
                            },
                            signOutButton: {
                                id: 'apple-sign-out-button',
                                theme: 'white-with-outline'
                            }
                        }
                    }]
                });

                // console.log("loaded cloudkit", CloudKit);

                function gotoAuthenticatedState(userIdentity) {
                    let name = userIdentity.nameComponents;
                    
                    if(name) {
                        // document.getElementById('message').innerHTML = ('Welcome, ' + name.givenName);    
                    } else {
                        // document.getElementById('message').innerHTML = ('Welcome!');
                    }

                    // document.getElementById('message').innerHTML += " You can search now.";
                }

                function gotoUnauthenticatedState(error) {

                    if(error && error.ckErrorCode === 'AUTH_PERSIST_ERROR') {
                    window.showDialogForPersistError();
                    }

                    document.getElementById('message').innerHTML = ("Apple <a href='https://www.apple.com/icloud/'>iCloud</a> account required.");
                }

                CloudKit.getDefaultContainer()
                    .whenUserSignsIn()
                    .then(gotoAuthenticatedState)
                    .catch(gotoUnauthenticatedState);

                CloudKit.getDefaultContainer().setUpAuth().then(function(userInfo) {
                    console.log("setupAuth:", userInfo);
                    if (ok) {
                        document.getElementById('summary').placeholder = 'OK: Searching………';
                        document.title = "OK: " + (params.get('q') || 'Search');
                        setTimeout(performSearch, 0);
                    }
                });

            } catch (e) {
                console.error("error loading cloudkit", e);
            }
        };
        window.addEventListener('cloudkitloaded', initCloudKit);

        if (ok) {
            document.getElementById('summary').placeholder = "OK: Searching……";
        }
    </script>
    <script src="https://cdn.apple-cloudkit.com/ck/2/cloudkit.js"></script>
</body>

</html>