<html>
<head>
    <meta charset="UTF-8">
    <title>Oki Dokey Search</title>
    <meta name="description" content="Oki Dokey Search" />

    <style>
    html, body {
        /* filter: hue-rotate(310deg); */
        max-width: 100%;
        /* overflow-x: hidden; */
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        margin: 0;
        padding: 0;
    }

    div.pagelink {
        width: 33vw !important;
        white-space: normal; 
        overflow-wrap: break-word;
        word-wrap: break-word;
        white-space: pre; /* CSS 2.0 */
        white-space: pre-wrap; /* CSS 2.1 */
        white-space: pre-line; /* CSS 3.0 */
        white-space: -pre-wrap; /* Opera 4-6 */
        white-space: -o-pre-wrap; /* Opera 7 */
        white-space: -moz-pre-wrap; /* Mozilla */
        word-wrap: break-word; /* IE 5+ */
    }


    @media screen and (prefers-color-scheme: dark) {
    /* body {
        background: #2d3239;
        color: #75715e;
    }

    h1 {
        color: #e9d970;
    } */
    }

    .recordKey {
        width: 10vw;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        font-variant-caps: small-caps; 
        text-align: right; 
        font-size: 1em;
        vertical-align: text-top;
    }

    .recordValue td {
        width: 48vw;
        overflow: hidden;
        text-overflow: ellipsis;
        font-size: 1em;
        overflow-wrap: break-word; 
        white-space: normal; 
    }

    .searchMeta {
    }

    .searchResult {
        width: 48vw;
        margin-left: 1vw;
        margin-right: 1vw;
        overflow-x: hidden;
    }

    .previewArea {
        width: 48vw;
        margin-left: 1vw;
        margin-right: 1vw;
        height: 10em;
        font-size: 1em;
        scroll-behavior: smooth;
        overflow: scroll; 
        overflow-x: hidden;
    }

    iframe.previewArea {
        /* visibility: hidden; */
        background-color: lemonchiffon;
        resize: both;
        padding: 0;
        border: 0; /* otherwise the border is different from the textarea */
        box-shadow: inset 0 0 1px;
        /* border: 0; */
        /* inset: 0; */
    }

    textarea.previewArea {
        padding: 0.5em;
        border-radius: 5px;
        border: 2px rgba(#000000, 0.5);
        scrollbar-width: thin;
        background-color: aliceblue;
        text-align: justify; 
        hyphens: auto; 
        overflow-wrap: break-word; 
        white-space: normal; 
        text-align: justify;
        white-space: pre-line;
        -moz-text-align-last: left;
        text-align-last: left;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
    }

    .previewArea::-webkit-scrollbar {
		width: 12px;
	}

	.previewArea::-webkit-scrollbar-button {
	}

	.previewArea::-webkit-scrollbar-track {
		-webkit-box-shadow: inset 0 0 3px rgba(0,0,0,0.5);
		box-shadow: inset 0 0 3px rgba(0,0,0,0.5);
		border-radius: 5px;
	}

	.previewArea::-webkit-scrollbar-track-piece {
	}

	.previewArea::-webkit-scrollbar-thumb {
		border-radius: 5px;
		background: rgba(#000000, 0.8);
		-webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.5);
	}

	.previewArea::-webkit-scrollbar-corner {
	}

	.previewArea::-webkit-resizer {
	}
    
	.previewArea::-webkit-scrollbar-thumb:window-inactive {
		background: rgba(#e89b4d, 0.4);
	}
    </style>
</head>

<body>
    <div style="margin-left: 1vw; margin-right: 1vw; margin-top: 1em; margin-bottom: 1em;">

    <form onsubmit="document.getElementById('summary').placeholder = 'searching…';">
        <input id="searchField" style="width: 37vw;" placeholder="Search terms" name="q" autofocus type="text" aria-autocomplete="both" aria-haspopup="false" autocapitalize="off" autocomplete="off" autocorrect="off" role="combobox" spellcheck="false" aria-label="Search"/>
        <input id="searchSubmit" type="submit" name="ok" value="Search" style="width: 10vw; padding-right: 1wv;" />
        <input id="resultsLimitField" style="width: 40px" name="l" placeholder="limit" />
        <input id="resultsDomainField" style="width: 100px" name="d" placeholder="host" />
        <input id="mimeTypeField" style="width: 100px" name="m" placeholder="type" />
        
        <input id="summary" style="xxxwidth: 100px" placeholder="" disabled />
        <input id="token" type="hidden" name="t"/>
        <input id="countOnly" type="checkbox" name="c" value="1" style="display: none;" />
        <!-- <small>count</small> -->
        <input id="unindexed" type="checkbox" name="x" value="1" style="display: none;" />
        <!-- <small>unindexed</small> -->
    </form>
    </div>
    <hr />
    <div id="results">
    </div>

    <script>
        "use strict";

        const params = new URLSearchParams(window.location.search);
        const ok = typeof params.get('ok') === 'string';
        document.getElementById('token').value = params.get('t');

        function escapeHtml(unsafe) {
            return unsafe
                .replace(/&/g, "&amp;")
                .replace(/</g, "&lt;")
                .replace(/>/g, "&gt;")
                .replace(/"/g, "&quot;")
                .replace(/'/g, "&#039;");
        }

        function sleep(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        function reverseString(str) {
            return str.split("").reverse().join("");
        }

        function changeMode(type, recordName, rlink) {
            console.log("changeMode", type, recordName);
            let textarea = document.getElementById('textarea-' + recordName);
            let iframe = document.getElementById('iframe-' + recordName);

            if (type === 'text') {
                iframe.hidden = true;
                textarea.hidden = false;
                //iframe.src = 'about:blank'; // clear the iframe's source
            } else if (type === 'preview') {
                textarea.hidden = true;
                iframe.hidden = false;
                if (iframe.src !== rlink) {
                    iframe.src = rlink;
                }  
            }
        }

        const recordElement = function (record, deferSnippetRender) {
            let deleted = record['deleted'];
            if (deleted !== false) { return; }

            let fields = record.fields;
            if (typeof fields !== 'object') {
                console.warn("record.fields was not an object!");
                return;
            }
            
            // the record's URL, which is either the 'responseURL', or the 'recordName' if it isn't set
            let rname = record['recordName'] || '';
            let rlink = (fields['responseURL'] || {}).value || ("https://" + rname);

            var html = "";
            html += "<div style='display: flex;'>";

            html += "<div class='searchMeta'>";

            html += "<textarea id='textarea-" + rname + "' class='previewArea' readonly>"
            let textObject = fields['text'];
            let snippet = (textObject || {}).value;
            if (deferSnippetRender <= 0) {
                if (typeof textObject === 'object') {
                    html += escapeHtml(snippet);
                }
            } else { // fill in snippets after a delay
                let updateSnippet = function () {
                    (document.getElementById('textarea-' + rname) || {}).innerHTML = escapeHtml(snippet);
                };
                setTimeout(updateSnippet, deferSnippetRender);
            }

            html += "</textarea>";
            html += "<iframe hidden id='iframe-" + rname + "' class='previewArea' referrerpolicy='no-referrer' sandbox='allow-forms allow-same-origin' src='about:blank'></iframe>";
            html += "</div>";

            var keys = Object.keys(fields);
            keys = keys.sort();

            keys = [
                "title",
                "indexDate",
                "contentType",
                "statusCode",
                "weight",
                "height",
                "text",
                "langs",
            ];
            // console.log("loaded keys", keys);

            html += "<div class='xxxsearchResult'>";

            html += "<table class='searchResult'>";

            keys.forEach(key => {
                html += "<tr>";

                html += "<td class='recordKey'>";
                html += key;
                html += "</td>";

                html += "<td class='recordValue'>";

                if (typeof fields[key] === 'undefined') {
                    // check the record along with the fields, so we can handle "recordName", "modifiedDate", etc.
                    if (typeof record[key] === 'string') {
                        html += record[key];
                    } else {
                        html += "<span style='font-variant-caps: small-caps;'>null</span>";
                    }
                } else if (key == 'title') {
                    html += "<strong>";
                    html += escapeHtml(fields[key].value);
                    html += "</strong>";
                } else if (key == 'indexDate') {
                    html += new Date(fields[key].value);
                } else if (key == 'text') {
                    let textlen = fields[key].value.length;
                    html += textlen + " bytes";
                    let weight = (fields['weight'] || {}).value;
                    if (typeof weight === 'number') {
                        html += " (" + (textlen / weight) + "%)";
                    }
                } else if (typeof fields[key] === 'object') {
                    html += fields[key].value;
                } else {
                    html += "" // nothing
                }
                html += "</td>";
                html += "</td>";

                html += "</tr>";
            });


            let previewButtonStyle = "";
            let fopts = (((fields['frameOptions'] || {}).value) + '').toUpperCase();
            if (fopts === 'SAMEORIGIN' || fopts === 'DENY') {
                // when X-Frame-Options is SAMEORIGIN or DENY, iframe loading is prohibited
                //console.log("FRAME", fopts, previewButtonStyle);
                previewButtonStyle = "style='text-decoration: line-through;' title='Sandbox preview forbidden by server policy: " + fopts + "' disabled";
            }

            html += "<tr>";
            html += "<td class='recordKey'>";
            html += "Preview";
            html += "</td>";

            html += "<td class='recordValue'>";

            html += "<form>"; 
            html += "<input type='radio' name='mode' value='text' onclick='changeMode(\"text\", \"" + rname + "\", \"" + rlink + "\")' checked ><label for='text'>Snippet</label></input>"

            html += "&nbsp;";

            html += "<input type='radio' name='mode' value='preview' onclick='changeMode(\"preview\", \"" + rname + "\", \"" + rlink + "\")' " + previewButtonStyle + ">";
            html += "<label for='preview' " + previewButtonStyle + ">Sandbox</label>";
            html += "</input>"
            html += "<br/>";

            html += "<div class='pagelink'><a class='pagelink' href='" + rlink + "'>" + rlink + "</a></div>";
            html += "</form>"; 

            html += "</td>";
            html += "</tr>";
            html += "</table>";

            html += "</div>"; // recordURL

            html += "</div>"; // searchResult
            return html;
        }

        const performSearch = function () {
            let startTime = new Date();
            var container = CloudKit.getDefaultContainer();
            var database = container.publicCloudDatabase;

            var filters = [];

            var desiredKeys = null;
            var defaultResultsLimit = '10';

            const countOnly = params.get('c') === '1';
            document.getElementById('countOnly').checked = countOnly;
            if (countOnly === true) {
                console.log("countOnly");
                defaultResultsLimit = '999';
                desiredKeys = ["indexDate"]; // request no keys; doesn't seem to have any effect!
            }

            const unindexed = params.get('x') === '1';
            document.getElementById('unindexed').checked = unindexed;

            if (unindexed === true) {
                console.log("unindexed");
                filters.push({
                        fieldName: 'indexDate',
                        comparator: 'EQUALS',
                        fieldValue: { value: 0 }
                    });
            } else {
                filters.push({
                        fieldName: 'indexDate',
                        comparator: 'NOT_EQUALS',
                        fieldValue: { value: 0 }
                    });
                    filters.push({
                        fieldName: 'weight',
                        comparator: 'GREATER_THAN',
                        fieldValue: { value: 0 }
                    });
            }

            let lim = params.get('l');
            document.getElementById('resultsLimitField').value = lim;
            var resultsLimit = null;
            if (typeof lim === 'string' && parseInt(lim) > 0) {
                resultsLimit = Math.max(1, parseInt(lim || defaultResultsLimit)); 
            } 

            const resultsDomain = params.get('d') || '';
            if (resultsDomain.length > 0) {
                document.getElementById('resultsDomainField').value = resultsDomain;
                filters.push({
                        fieldName: 'rhost',
                        comparator: 'BEGINS_WITH',
                        fieldValue: { value: reverseString(resultsDomain) }
                    });
            }

            const resultsMIME = params.get('m') || '';
            if (resultsMIME.length > 0) {
                document.getElementById('mimeTypeField').value = resultsMIME;
                filters.push({
                        fieldName: 'rmime',
                        comparator: 'BEGINS_WITH',
                        fieldValue: { value: reverseString(resultsMIME) }
                    });
            }

            // issue the query
            const queryString = params.get('q') || '';
            if (queryString.length > 0) {
                // pre-fill the search field
                document.getElementById('searchField').value = queryString;

                filters.push({
                        fieldName: 'text',
                        comparator: 'CONTAINS_ALL_TOKENS',
                        fieldValue: { value: queryString }
                    });
            }

            var sortDescriptors = [];
            sortDescriptors.push({ // most recent first
                //"systemFieldName": "createdTimestamp",
                "systemFieldName": "modifiedTimestamp",
                "ascending": false
            });

            //document.getElementById('results').innerHTML = "Searching…"

            var query = {
                recordType: 'Page',
                resultsLimit: resultsLimit,
                desiredKeys: desiredKeys,
                numbersAsStrings: false,
                sortBy: sortDescriptors,
                filterBy: filters
            };

            let div = document.getElementById('results');
            div.innerHTML = "";
            var recordResults = [];
            var deferSnippetRender = 0; // 500; // the number of ms before we will fill in the snippets; doesn't seem to improve performance

            const handleResponse = function (response) {
                //console.log("record count", response.records.length);
                //console.log("receive response", response, response.records);

                var divhtml = "";
                response.records.forEach(element => {
                    //document.getElementById('summary').placeholder += "…";

                    if (resultsLimit === null || recordResults.length < resultsLimit) {
                        recordResults.push(element);
                        if (countOnly === false) {
                            divhtml += recordElement(element, deferSnippetRender) + "<hr />";
                            if (deferSnippetRender > 0) {
                                deferSnippetRender += 500;
                            }
                        }
                    }
                });
                div.innerHTML = divhtml; // much faster to set it all at once

                if (response.moreComing && resultsLimit !== null && (recordResults.length < resultsLimit)) { // there are more results…
                    console.log("executing continuation", response.continuationMarker);
                    database.performQuery(response) // …so execute the continuation
                        .then(function (response) { handleResponse(response); })
                        .catch(function (error) { console.warn(error); });
                } else {
                    let sum = document.getElementById('summary');
                    let plus = (resultsLimit == null || recordResults.length >= resultsLimit) && response.moreComing == true ? "+" : "";
                    sum.placeholder = recordResults.length + plus + " results in " + ((new Date().getTime() - startTime.getTime()) / 1000.0) + " seconds";
                }
            };

            database.performQuery(query)
                .then(function (response) { handleResponse(response); })
                .catch(function (error) { console.warn(error); });
        };

        /**
         * This function is run immediately after CloudKit has loaded.
         * 
         * Data Size Limits: These are the limits on the size of data sent to and from the CloudKit server.
         *
         *  Maximum number of operations in a request: 200
         *  Maximum number of records in a response: 200
         *  Maximum number of tokens in a request: 200
         *  Maximum record size (not including Asset fields): 1 MB
         *  Maximum file size of an Asset field: 50 MB
         *  Maximum number of source references to a single target where the action is delete self: 750
         */
        const initCloudKit = function () {
            try {
                CloudKit.configure({
                    logger: window.console,
                    containers: [{
                        containerIdentifier: 'iCloud.net.tiqtiq.TiqTiq',
                        environment: 'development',
                        apiTokenAuth: {
                            // note this only works with our origin host; use a local dev key in `t` for testing
                            apiToken: params.get('t') || 'a56fb0334eb8f142d81f36b4e59dd579d1407958f7084e2af48276a1514a9dcf',
                        }
                    }]
                });

                // console.log("loaded cloudkit", CloudKit);
                if (ok) {
                    performSearch();
                }
            } catch (e) {
                console.error("error loading cloudkit", e);
            }
        };
        window.addEventListener('cloudkitloaded', initCloudKit);
    </script>
    <script src="https://cdn.apple-cloudkit.com/ck/2/cloudkit.js"></script>
</body>
</html>